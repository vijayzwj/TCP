1  TCP三次握手，为什么TCP需要三次握手建立连接？
   
   ◉任何信息在物理介质上传输可能丢失的，这是由于传输截至的物理特性决定的。
   既然物理层无法提供可靠数据传输那么只能由协议提供可靠传输---TCP协议诞生了。
   
   注：信道是不可靠的，但是通信双方需要就某个问题达成一致。解决这个问题，无论你在消息中包含上面信息，三次通信是理论的最小值。
   三次握手不是TCP本身的要求，而是为了满足在不可靠对的信道上可靠的传输信息（这个需求决定的）。
   
   ◉本质需求：信道不可靠，数据传输要可靠。三次达到了，后面进行握手，发送收据跟进行可靠的信息传输的需求就没什么关系了。
   如果想确定双方通道通畅必须使用三个包的发送接收，即是三次握手。
   
   ◉为了防止已经失效的连接请求报文段又传送到Server端（网络中存在延迟的重复分组），而产生错误！
   解释：Client发出的第一个连接请求报文并没有丢失而是延迟较长，以至于延误到连接释放以后的某个时间才到达Server端。
   本来这是个失效的报文段。于是Server向Client发送确认，新的连接就建立了。而Client并没有发送建立连接请求，因此不会理睬Server端的确认。
   但是Server端连接已经建立，并一直等待Client发来数据。这样Server端资源就浪费了。
   
   ◉三次握手
   Client不会向服务器端发送确认。Server端收不到确认，就知道Client并没有要求建立连接。
  
   ◉TCP是全双工通信，三次握手证实双方都能收发
   
   Client   --------------------->   Server   Server知道Client能发
   
   
   Client   <----------------------  Server   Client知道Server能收发
   
   
   Client   -----------------------> Server   Server知道Client能收 

2 四次挥手断开连接？

  ◉断开连接时，双方都要发FIN，并且在收到FIN后回复ACK，但是这时被动关闭的一方并不把ACK和FIN一起合并返回。这是因为TCP是全双工的，每个方向
  必须单独关闭，TCP连接可以是半关闭状态。收到FIN只意味着这一方向上没有数再接受了，它给应用程序发送EOF，但是接受FIN一方仍然可以发送数据的。
  ◉发送FIN只是表示应用层不再发送数据了，但是缓冲区中的数据会继续发送出去。
  
  
3 TCP连接
  ◉TCP是面向连接的协议，并不存在真实的物理或者虚拟的链路，TCP的连接是指在通信双方分配了资源和维护状态。
  ◉资源：双方建立四元组（cleint_ip,clientport,server_ip,server_port）表示一个链接
         对每个连接，TCP管理4个不同的定时器。
         （
         重传定时器、【这个时间间隔通常如下:1s, 3s, 6s, 12s, 24, 48s, 和多个64s。TCP会一直尝试重传该数据，在9分钟以后放弃。】         
         为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。当TCP发送报文段时，就创建这个特定报文段的重传计时器，
         可能发生两种情况：若在计时器超时之前收到对报文段的确认，则撤销计时器；
                         若在收到对特定报文段的确认之前计时器超时，则重传该报文，并把计时器复位；
                         重传时间=2*RTT；
                         RTT的值应该动态计算。常用的公式是：RTT=previous RTT*i + （1-i）*current RTT。i的值通常取90%，
                         即新的RTT是以前的RTT值的90%加上当前RTT值的10%.
                         Karn算法：对重传报文，在计算新的RTT时，不考虑重传报文的RTT。
                         因为无法推理出：发送端所收到的确认是对上一次报文段的确认还是对重传报文段的确认。干脆不计入。
         
         2MSL定时器、
         2MSL定时器测量一个连接处于TIME_WAIT状态的时间。2MSL时间是为了让TCP有时间发送最后一个ACK,防止该ACK丢失。
         在连接终止期使用，当TCP关闭连接时，并不认为这个连接就真正关闭了，在时间等待期间，连接还处于一种中间过度状态。
         这样就可以时重复的fin报文段在到达终点后被丢弃，这个计时器的值通常设置为一格报文段寿命期望值的两倍。
         
         persist定时器【TCP不会对ACK进行确认，可能出现ACK丢失，导致窗口失败。此时需要定期发送1字节的窗口探测报文。】
         坚持定时器正是为了解决这个问题，它在接收到一个窗口大小为0的ACK以后，启动一个定时器，定时去查询是否窗口已经更新（同样采用指针退避）。
         
         keepalive定时器【查看链接是否存活，报文只带ACK标志，且seq=发送序号-1，这样对方进行一个ACK，表示收到重复序号，对端期望下一个值,
                         保活定时器通常每两小时发送一个探测请求以查看对方是否存活。】） 
         
         发送方：发送缓冲区、4个定时器、接收窗口、拥塞状态计数器
         接收方：接收缓冲区、4个定时器、接收窗口、拥塞状态计数器
         
  ◉通信双方通过内部状态保持彼此的信息，连接关系始终保持，并通过报文交换来进行连接状态变更。
    除了确认报文本身不被确认外，其他报文都有ACK进行确认，报文有可能超时需要重传。
  
  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    





